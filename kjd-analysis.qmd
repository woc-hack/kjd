---
title: "KJD Analysis"
author: "James Walden"
editor: visual
format: pdf
pdf:
  toc: true
  number-sections: true
  colorlinks: true
---

## KJD Analysis

We investigate the prevalance and survival time of cloned vulnerable files. We start with the CVEfixes dataset, then find projects containing such vulnerabilities in the World of Code and search for the vulnerable files in other WoC projects.

```{r}
#| echo: false
#| output: false
library(tidyverse)
library(fs)
library(lubridate)
library(tidymodels)
set.seed(101)
```

## Data

We use two data sets: CVEfixes to find vulnerable files, and World of Code to find where those files have been copied to.

The CVEfixes dataset was generated by Kristiina on _FIXME: DATE_ using the code found in the CVEfixes repository at https://github.com/secureIT-project/CVEfixes. There is no missing data in this dataset, though not all projects containing CVEs from this dataset exist in the World of Code.

```{r}
data_path <- path('data')
woc_path <- path(data_path, '11.04')
```

```{r}
cve <- read_delim(path(data_path, 'cvefixes_new.csv'),
                  delim=';', 
                  col_names=c('CVE','commit','url','pathname','create_time','fix_time'),
                  col_types='ccccTT')
```

This dataset has 3615 vulnerabilities and 6 columns of data about them.

```{r}
#| echo: false
dim(cve)
```

There is no missing data in any column of the CVEfixes dataset.
```{r}
cve |> summarize(across(, ~sum(is.na(.x))))
```

The World of Code dataset contains data collected on projects that have vulnerabilities listed in the CVEfixes dataset. It was constructed using David's scripts in the KJD repository.

We read in the UNIX timestamp format columns as doubles, since the default 32-bit integers are not long enough to store those values.
```{r}
woc_new <- read_csv(path(woc_path, 'final_filter0.csv.xz'),
                col_names = TRUE,
                col_types = 'ccccccdcdiciciciddciiiiiiciicc')
```

Check number of missing values in each column.
```{r rows.print=30}
woc_new_missing <- woc_new |> 
  summarize(across(, ~sum(is.na(.x)))) |>
  pivot_longer(cols=everything(), names_to='metric', values_to='count')
woc_new_missing |> arrange(desc(count))
```

We find multiple columns containing rows that are missing the same large number of values, which is more than 96% of all rows.
```{r}
woc_new_missing |> summarize(max = max(count), pct = max/nrow(woc_new))
```

Convert datetime and logical data types that read_csv doesn't handle.
```{r}
woc <- woc_new
woc$FirstBadTime <- as_datetime(woc$FirstBadTime)
woc$FirstGoodTime <- as_datetime(woc$FirstGoodTime)
woc$EarliestCommitDate <- as_datetime(woc$EarliestCommitDate)
woc$LatestCommitDate <- as_datetime(woc$LatestCommitDate)
woc$SECURITY.md <- ifelse(woc$SECURITY.md=="Yes", TRUE, FALSE)
woc$Corp <- ifelse(woc$Corp=="Yes", TRUE, FALSE)
```

If we remove all rows with missing values in the columns below, we remove about 2% of the dataset. We keep rows with missing data in the star count (GHStars, NumStars) and GitHub commits (GHCommits), along with the 8 time columns beginning with First or Time in which over 96% of rows have missing data. 
```{r}
wocnona <- woc |> 
    drop_na(all_of(c('FirstBadBlob','FirstBadTime','CommunitySize','NumForks',
    'Path','FileInfo','NumCommits','NumCore','NumCommits','NumAuthors')))
nrow(woc) - nrow(wocnona)
```

__NOTE:__ Use woc for the whole data set, wocnona for data without most missing data.

## RQ1: How prevalent are cloned files with vulnerabilities?

There are 3022 cloned vulnerabilities out of 3615 total (83.6%) in the CVE fixes dataset.
```{r}
wocnona |> select(CVE) |> distinct() |> summarize(n=n(), pct=n()/nrow(cve))
```

There are 720,128 unique projects containing cloned vulnerabilities.
```{r}
wocnona |> select(Project) |> distinct() |> count()
```

There are over 3 million cloned vulnerable files.
```{r}
wocnona |> select(CVE) |> count()
```

The median project has only a single cloned vulnerability and the third quartile starts at two vulnerabilities. However, the mean is 4.237 and the maximum is 807 cloned vulnerabilities in a single project.
```{r}
vulnsperproj <- wocnona |> 
    group_by(Project) |> 
    summarize(numvulns=n()) |> 
    arrange(desc(numvulns))
summary(vulnsperproj |> select(numvulns))
```

We can visualize vulnerabilities per project as a boxplot. The box is squashed as the IQR is 1 while there is a long tail of high outliers going up to 807.
```{r, fig.height=2, fig.width=12}
ggplot(data=vulnsperproj, aes(x=numvulns, y=1)) + geom_boxplot()
```

58.3% of all projects have only a single cloned vulnerability.
```{r}
proj_counts <- 
  vulnsperproj |> 
  group_by(numvulns) |> 
  summarize(nprojects=n(), percent=format(100*n()/nrow(vulnsperproj), scientific=FALSE))
proj_counts
```

Over 90% (90.8%) of projects have 1-3 vulnerabilities, while 97.5% of projects have 10 or fewer cloned vulnerabilities.
```{r}
proj_counts_top3 <- proj_counts |> slice_max(n=3, order_by=nprojects) |> pull(nprojects) |> sum()
proj_counts_top10 <- proj_counts |> slice_max(n=10, order_by=nprojects) |> pull(nprojects) |> sum()
tibble(nvulns_1_3=proj_counts_top3, pct3=100*proj_counts_top3/nrow(vulnsperproj),
       nvulns_1_10=proj_counts_top10, pct10=100*proj_counts_top10/nrow(vulnsperproj))
```


## RQ2: What are characteristics of projects containing cloned files with vulnerabilities?

Since the research question asks about projects, not vulnerabilities, we create a data frame with one row per WoC project. There are 720,128 projects in the dataset.

```{r}
numvulns <- wocnona |> 
  group_by(Project) |> 
  summarize(NumVulns=n(),
            NumFixed=sum(status=="fixed"),
            NumUnfixed=sum(status=="notfixed"),
            NumUnknown=sum(status=="unknown")
  )
```

```{r}
projects <- 
  left_join(numvulns, wocnona, by="Project") |>
  group_by(Project) |>
  slice(1) |>
  ungroup()
```

__Sources__

Separate out the ProjectURL into Source and Path fields. This works on all lines but the line for CVE-2013-7223 in project "mmarkoul_demo_app", which has the string "githProjectUrl" in the ProjectURL field.
```{r}
project_sources <- projects |>
  filter(ProjectUrl != "githProjectUrl") |>
  separate(ProjectUrl, c("Source","Path"), sep="/", extra="merge") |>
  mutate(Source = as.factor(Source))
```

The vast majority (about 98.5%) of projects are from GitHub, with only about 1.5% being from Gitlab.
```{r}
project_sources |> select(Source) |> summary()
```

__Commits__

The median number of commits is very low (7), while the mean is much higher (11,705), indicating that many projects have few commits.
```{r}
projects |> select(NumCommits) |> summary()
```

A boxplot shows that the distribution of commits per project has a huge number of outliers above the median, some of which are extremely far from the median.
```{r, fig.height=2, fig.width=12}
ggplot(data=projects, aes(x=NumCommits, y=1)) + geom_boxplot()
```

When viewing how many projects have each number of commits, we see hundreds of thousands of projects for numbers of commits <= 6 and tens of thousands of projects for numbers of commits <= 41.
```{r}
freq_commits <- projects |> 
    group_by(NumCommits) |> 
    select(NumCommits) |> 
    summarize(nprojects=n(), 
              percent=format(100*nprojects/nrow(projects), scientific=F))
freq_commits
```

```{r, fig.width=12}
freq100 <- freq_commits |> head(100)
ggplot(data=freq100, aes(x=NumCommits, y=nprojects)) + 
  geom_point() +
  scale_x_continuous(n.breaks=10) +
  scale_y_continuous(n.breaks=10) +
  ylab("Number of Projects")
```

61.3% of projects have 10 or fewer commits.
```{r}
freq_commits |> 
  slice(1:10) |> 
  summarize(n=sum(nprojects),
            percent=format(100*n/nrow(projects), scientific=F))
```

We can zoom in to look at the data without the top 10 numbers of commits.
```{r, fig.width=12}
freq_no_top10 <- freq_commits |> head(100) |> tail(90)
ggplot(data=freq_no_top10, aes(x=NumCommits, y=nprojects)) + 
  geom_point() +
  scale_x_continuous(n.breaks=10) +
  scale_y_continuous(n.breaks=10) +
  ylab("Number of Projects")
```

__Authors__

The median number of authors is 1, while the mean is much higher (55.79), indicating that many projects have a single or few authors.
```{r}
projects |> select(NumAuthors) |> summary()
```

When viewing how many projects have each number of authors, we find that 71% of projects have a single author and 19.2% have two authors, meaning 90% of projects have only one or two authors.
```{r}
freq_authors <- projects |> 
    group_by(NumAuthors) |> 
    select(NumAuthors) |> 
    summarize(nprojects=n(), 
              percent=format(100*nprojects/nrow(projects), scientific=F))
freq_authors
```

We take a sample of 0.1% of vulnerable clones to examine the relationship between
the numbers of commits and authors, eliminating outliers with more than 1000 authors
or 10,000 commits.
```{r}
scatter_sample <- wocnona |>
  filter(NumAuthors < 1e3 & NumCommits < 1e4) |>
  slice_sample(n=25000)
```

Plotting the sample, we see a linear relationship with larger numbers of authors
indicating larger numbers of commits, though there are a considerable number of
outliers.
```{r}
ggplot(scatter_sample, aes(x=NumAuthors, y=NumCommits)) + 
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, level = 0.99)
```

__Community Size__

The median community size is 1, while the mean is much higher (60.1), indicating that many projects have no or very small communities.
```{r}
projects |> select(CommunitySize) |> summary()
```

The large majority (85%) of projects have a community size of 1, while another 10% have a community size of 2.
```{r}
freq_community <- projects |> 
    group_by(CommunitySize) |> 
    select(CommunitySize) |> 
    summarize(nprojects=n(), 
              percent=format(100*nprojects/nrow(projects), scientific=F))
freq_community
```

A bit less than 1% of projects have a community size of 10 or more.
```{r}
freq_community |>
  filter(CommunitySize > 10) |>
  summarize(n=sum(nprojects),
            percent=format(100*n/nrow(projects), scientific=F))
```

We take a sample of 0.1% of vulnerable clones to examine the relationship between
the numbers of commits and authors, eliminating outliers with more than 10,000 authors
or 10,000 community members.
```{r}
scatter_sample <- wocnona |>
  filter(NumAuthors < 1e4 & CommunitySize < 1e4) |>
  slice_sample(n=25000)
```

Plotting the sample, we see a linear relationship with larger numbers of authors
indicating larger numbers of commits, though there are a considerable number of
outliers.
```{r}
ggplot(scatter_sample, aes(x=NumAuthors, y=CommunitySize)) + 
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, level = 0.99)
```

__GitHub Stars__

Eliminate rows without GitHub stars before analyzing the star data. There are 17,194 projects with missing GH star data out of over 720,000 projects total.
```{r}
wocghstars <- projects |> drop_na(GHStars)
nrow(projects) - nrow(wocghstars)
```

The median number of stars is 0, while the mean is much higher (26.1), indicating that many projects have no or few stars.
```{r}
wocghstars |> select(GHStars) |> summary()
```

The large majority (83.3%) of projects have zero stars, while 10.4% have a single star, making up over 90% of all projects for which we have star data.
```{r}
freq_ghstars <- wocghstars |> 
    group_by(GHStars) |> 
    select(GHStars) |> 
    summarize(nprojects=n(), 
              percent=format(100*nprojects/nrow(projects), scientific=F))
freq_ghstars
```


__Language__

Create an Extension column with the file extension and count each file extension. We find that 62.6% vulnerabilities are found C files, 23.8% in JavaScript, 6.4% in PHP, 3.4% in Ruby, 1.25% in C++ (1.12% .cc + 0.13% .cpp), and 0.94% in C header files.

A small number of vulnerabilities (dozens) are tied to generic text files (.txt, .html) or specific text files (CHANGES). The same is true for generic (htaccess) and specific configuration files (Kconfig). There are a few XML, YAML, and HAML format files too as well as template files with .erb and .rhtml extensions. 16 files have a .old extension.

```{r}
extensions <- wocnona |> 
       extract(Path, "Extension", "\\.([^.]+)$", remove=FALSE) |>
       group_by(Extension) |>
       count() |>
       mutate(percent = format(100 * n / nrow(wocnona), scientific=FALSE)) |>
       arrange(desc(n))
extensions
```

### Correlations

Create a subset containing the numeric non-datetime columns that do not have NAs.
```{r}
wocnona_numeric <- wocnona |>
  select(where(is.numeric)) |>
  select(where(~ !any(is.na(.)))) |>
  select(!starts_with("Time"))
```

Print a correlation matrix of these columns.
```{r}
cor(wocnona_numeric)
```

We see extremely strong (>0.9) correlations between NumAuthors, NumCommits, NumForks, and CommunitySize.

## RQ3: What percentage of cloned vulnerabilities are fixed

Let us create a data frame containing only the fixed vulnerabilities. There are 
101,064 fixed vulnerabilities in the WoC dataset. These files make up only 3.3%
of cloned vulnerabilities in our dataset. 

There are about 69,000 or 2.3% of cloned vulnerabilities with status unknown. Such
files have changed since the vulnerability was introduced, but are not identical
to the fixed file from the original project. David's more detailed explanation of
how files are classified as fixed, notfixed, or unknown is:

    I get the history of the vulnerable file in the original project that is
    listed in cve fixes. All blobs before the fixing commit are considered
    bad blobs. The blob in the fixing commit and all subsequent blobs are
    considered good blobs. If the project that cloned the vulnerable file
    has a blob from the good blobs list, it is considered fixed. If the
    latest version of the file is in the bad_blobs list, it is considered
    not fixed. If the latest version of the file is not in the good or bad
    list, then we know the file was changed, but we don't know if the change
    fixed the vulnerability.

```{r}
fixedvulns <- wocnona |> filter(status == "fixed")
```

```{r}
wocnona |> 
  group_by(status) |>
  summarize( nvulns=n(),
             percent=100*nvulns/nrow(wocnona)
           )
```

Fixed vulnerabilities are found in 26,809 different projects. Projects with fixed
vulnerabilities represent only 3.7% of all projects.
```{r}
fixedvulns |> 
  distinct(Project) |> 
  summarize(nprojects=n(), percent=100*nprojects/nrow(projects))
```

Let's create a data frame of projects with counts of their fixed, unfixed, and unknown vulnerabilities.
```{r}
project_status <- wocnona |>
  group_by(Project, status) |>
  summarize(nvulns = n(), .groups = 'drop') |>
  pivot_wider(names_from = status, values_from = nvulns) |>
  replace_na(list(fixed=0, notfixed=0, unknown=0))
```

How many projects have fixed all of their cloned vulnerabilities? 14,721 projects (2% of all projects, 55% of projects that have fixed at least one vulnerability).
```{r}
fixedprojects <- project_status |> filter(fixed > 0 & notfixed == 0)
fixedprojects |> 
  summarize(nprojects=n(), 
            pct_all=100*nprojects/nrow(project_status),
            pct_fixed=100*nprojects/nrow(fixedvulns |> distinct(Project))
  )
```

Let's look at how many vulnerabilities projects have fixed.
```{r}
fixedprojects |> arrange(desc(fixed))
```

We plot the distribution of the number of fixed vulnerabilities, removing outliers (projects with more than 10 fixed vulnerabilities).
```{r}
ggplot(fixedprojects |> filter(fixed <= 10), aes(x=fixed)) + 
  geom_density() +
  scale_x_continuous(name="Number of Fixed Vulnerabilities", breaks=1:10)
```

How many projects have both fixed and unfixed vulnerabilities? There are over 12,000 projects with both, making up 1.7% of all projects and 45% of projects that have fixed at least one vulnerability.
```{r}
mixedprojects <- project_status |> filter(fixed > 0 & notfixed > 0)
mixedprojects |> 
  summarize(nprojects=n(), 
            pct_all=100*nprojects/nrow(project_status),
            pct_fixed=100*nprojects/nrow(fixedvulns |> distinct(Project))
  )
```

Let's look at the mixed projects.
```{r}
mixedprojects
```

Mixed projects have a median of 1 fixed and 5 unfixed vulnerabilities and a mean of 4.8 fixed and 47.7 unfixed vulnerabilities.
```{r}
summary(mixedprojects)
```

Let's plot the distribution of fixed and unfixed vulnerabilities for mixed projects.
```{r}
cutoff <- 10
ggplot(mixedprojects |> filter(fixed <= cutoff & notfixed <= cutoff)) + 
  geom_density(aes(x=fixed), color="blue") +
  geom_density(aes(x=notfixed), color="red") +
  scale_x_continuous(name="Number of Fixed Vulnerabilities", breaks=1:10)
```

### How many vulnerabilities are fixed before they're vulnerable?

```{r}
validfixed <- fixedvulns |> filter(ValidDates == "OK")
nrow(validfixed)
```

We find that 11,794 projects (12.3%) with valid dates have cloned files that
replicate the fixed file before they replicate the vulnerable file.
```{r}
validfixed |> 
  filter(FirstGoodTime < FirstBadTime) |>
  summarize(nvulns = n(), percent=100*nvulns/nrow(validfixed))
```

### Time Distribution of Vulnerability Introduction and Fixing

To examine the time evolution of adding and fixing vulnerable cloned files, I
plotted several of the projects with both fixed and unfixed vulnerabilities over
time, but I found only 2 different dates in each of them:

```{r fig.height=2}
p <- validfixed |> filter(Project == '5l1v3r1_medusa-4')
ggplot(data=p) + geom_point(color="red", aes(x=FirstBadTime,y=1)) + geom_point(color="blue", aes(x=FirstGoodTime, y=2))
```


```{r fig.height=2}
p2 <- validfixed |> filter(Project == 'yllg_wasm-ffmpeg')
ggplot(data=p2) + geom_point(color="red", aes(x=FirstBadTime,y=1)) + geom_point(color="blue", aes(x=FirstGoodTime, y=2))
```

Let us see how many different good and bad times each project has.
```{r}
woctimes <- wocnona |>
  group_by(Project) |>
  summarize(nbadtimes=n_distinct(FirstBadTime),
            ngoodtimes=n_distinct(FirstGoodTime),
            nvulns=n()) |>
  arrange(desc(nbadtimes), desc(ngoodtimes))
woctimes
```

While there are projects that have many more than one or two of each time, 94% of projects only have one of each time.
```{r}
woctimes |> 
  filter(nbadtimes==1 & ngoodtimes == 1) |>
  summarize(nprojects=n(),
            percent=100*nprojects/nrow(woctimes))
```

36% of projects have more than one vulnerability but still only have one vulnerability
introduction time and one vulnerability fix time.
```{r}
woctimes |> 
  filter(nbadtimes==1 & ngoodtimes == 1 & nvulns > 1) |>
  summarize(nprojects=n(),
            percent=100*nprojects/nrow(woctimes))
```

There is a power law distribution of projects with more than 1 vulnerability but
only a single bad time and a single fixed time. The distribution is of the same
form as the overall distributions of number of projects with n vulnerabilities.
```{r}
wt_freq <- woctimes |> filter(nbadtimes==1 & ngoodtimes == 1 & nvulns > 1) |>
  group_by(nvulns) |>
  summarize(nprojects=n(),
            percent=format(100*nprojects/nrow(woctimes), scientific=FALSE))
wt_freq
```

## RQ4: How do project characteristics affect the percentage of fixed vulnerabilities?

Let's create a multiple regression model for the number of fixed vulnerabilities.

```{r}
fixed_model <- linear_reg() |>
  set_engine("lm") |>
  set_mode("regression")
```

```{r}
fit_fixed_model <- fixed_model |>
  fit(NumFixed ~ NumStars + NumCore + CommunitySize + NumCommits + NumForks, data=projects)
```

Let us examine the coefficients.
```{r}
tidy(fit_fixed_model)
```


### Relationship between fixed vulnerabilities and number of commits

There are 3917 fixed files in projects with only a single commit. Projects with a single commit fix <1% of their vulnerable files.
_FIXME:_ How can there be a fix with only one commit?
```{r}
files_1commit <- woc |> filter(NumCommits == 1)
tibble(onecommit=files_1commit |> count() |> pull(),
       fixed=files_1commit |> filter(!is.na(TimeVulnRemained)) |> count() |> pull(),
       percent_all=100*fixed/onecommit,
       percent_fixed=100*fixed/nrow(fixedvulns))
```

The majority of fixed files (81,111 or 78.6%) are in projects with 10 or more commits.
Projects with 10 or more commits fix 6.17% of their vulnerable cloned files.
```{r}
files_10commits <- woc |> filter(NumCommits >= 10)
tibble(tencommits=files_10commits |> count() |> pull(),
       fixed=files_10commits |> filter(!is.na(TimeVulnRemained)) |> count() |> pull(),
       percent_all=100*fixed/tencommits,
       percent_fixed=100*fixed/nrow(fixedvulns))
```

### Relationship between fixed vulnerabilities and number of authors

Projects with a single author fix less than 2% of their vulnerable clone files.
About 37.8% of all fixed vulnerable clones are in single author projects.
```{r}
files_1author <- woc |> filter(NumAuthors == 1)
tibble(oneauthor=files_1author |> count() |> pull(),
       fixed=files_1author |> filter(!is.na(TimeVulnRemained)) |> count() |> pull(),
       percent_all=100*fixed/oneauthor,
       percent_fixed=100*fixed/nrow(fixedvulns))
```

Substantially more vulnerable clones are fixed (10.9%) in projects with 10 or more authors.
About 21.8% of all fixed vulnerable clones are in projects with 10 or more authors.
```{r}
files_10authors <- woc |> filter(NumAuthors >= 10)
tibble(tenauthors=files_10authors |> count() |> pull(),
       fixed=files_10authors |> filter(!is.na(TimeVulnRemained)) |> count() |> pull(),
       percent_all=100*fixed/tenauthors,
       percent_fixed=100*fixed/nrow(fixedvulns))
```

## RQ5: How long does it take to fix a cloned vulnerability?

We analyze the TimeVulnRemained column, which measures the time between FirstGoodTime and max(FirstBadTime, Orig fix)) in days according to the file `VCAnalyzer/README.md`. An NA
value indicates that the vulnerability was never fixed. We have some questions about this
data column:

  - What do negative values mean?
  - Are very large (-18631 days = - 52 years) negative values meaningful?
  - How are values rounded?
  - What do zero values mean? Could they be small negative values before rounding, indicating a quick fix?

We only analyze rows that have valid dates, as determined by the value of ValidDates being set to the string "OK". This eliminates a few hundred thousand rows.
```{r}
woctime <- wocnona |> 
    filter(ValidDates == "OK")
nrow(wocnona) - nrow(woctime)
```

The large majority (96.7%) of cloned vulnerabilities are never fixed.
```{r}
unfixed <- woctime |> filter(is.na(TimeVulnRemained)) |> count() |> pull()
tibble(unfixed=unfixed, percent=100*unfixed/nrow(woctime))
```

Let us create a data frame containing only the fixed vulnerabilities. There are 103,196 fixed vulnerabilities in the woctime dataset.
```{r}
fixedvulns <- woctime |> filter(!is.na(TimeVulnRemained))
fixedvulns |> select(TimeVulnRemained) |> summary()
```

If vulnerabilities are fixed, many vulnerabilities (40.5% of those that are
ever fixed) are fixed in less than 1 day.  _FIXME: is that what 0 means?_

```{r}
zerofixed <- woctime |> filter(TimeVulnRemained == 0) |> count() |> pull()
tibble(zerofixed=zerofixed, 
       pct_total=100*zerofixed/nrow(woctime),
       pct_fixed=100*zerofixed/nrow(fixedvulns))
```

While 0 is the most common time to fix, 1, 2, and 3 days are also very common, as is 19 for some reason.
```{r}
daystofix <- fixedvulns |> 
    group_by(TimeVulnRemained) |> 
    select(TimeVulnRemained) |> 
    summarize(nvulns=n()) |> 
    arrange(desc(nvulns))
daystofix
```

Visualize vulnerabilities that are fixed in 30 or less days, excluding 0 to avoid shrinking the other bars to invisibility.
```{r fig.width=10}
daystofix_nooutliers <- daystofix |> 
  filter(TimeVulnRemained < 30 & TimeVulnRemained > -30) |> 
  filter(TimeVulnRemained != 0)
ggplot(data=daystofix_nooutliers, aes(x=TimeVulnRemained, y=nvulns)) + 
  geom_col() +
  ggtitle("Number of Vulnerabilities by Time to Fix")
```

There are somewhat more positive fix times than negative fix times.

```{r}
daystofix_positive <- daystofix |> filter(TimeVulnRemained > 0) |> count() |> pull()
daystofix_negative <- daystofix |> filter(TimeVulnRemained < 0) |> count() |> pull()
tibble(negative = daystofix_negative, positive = daystofix_positive)
```


Let's compare the distribution of the negative and positive fix times. We see that the negative days have a much greater range (-18631 days compared to 3530 days) and mean (-6717 days compared to 904 days).
```{r}
daystofix |> select(TimeVulnRemained) |> filter(TimeVulnRemained < 0) |> summary()
```

```{r}
daystofix |> select(TimeVulnRemained) |> filter(TimeVulnRemained > 0) |> summary()
```

__TODO__
  1. Analyze project characteristics of projects that fix vulnerabilities?
  2. Analyze characteristics of projects that fix vulnerabilities very fast (in 0 days)?
